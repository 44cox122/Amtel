
AVRASM ver. 2.2.7  C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm Thu Oct 25 20:24:13 2018

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(5): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(6): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\lcd_def.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(7): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\macros.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(85): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\delay.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(86): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\lcd.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(87): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\print_number.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(88): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\print_string.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(89): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\keypad.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(90): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\motor.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(91): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\user_input.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(5): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.209\avrasm\inc\m2560def.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(6): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\lcd_def.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(7): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\macros.inc'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(85): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\delay.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(86): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\lcd.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(87): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\print_number.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(88): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\print_string.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(89): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\keypad.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(90): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\motor.asm'
C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\monorail.asm(91): Including file 'C:\Users\lakew\Documents\Atmel Studio\7.0\cs2121\project\user_input.asm'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #define _M2560DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega2560
                                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x98
                                 .equ	SIGNATURE_002	= 0x01
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                                 .equ	PINL	= 0x109	; MEMORY MAPPED
                                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                                 .equ	PINK	= 0x106	; MEMORY MAPPED
                                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                                 .equ	PINH	= 0x100	; MEMORY MAPPED
                                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR5	= 0x1a
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTG	= 0x14
                                 .equ	DDRG	= 0x13
                                 .equ	PING	= 0x12
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	PORTA	= 0x02
                                 .equ	DDRA	= 0x01
                                 .equ	PINA	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 .equ	PORTG5	= 5	; 
                                 .equ	PG5	= 5	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 .equ	DDG5	= 5	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 .equ	PING5	= 5	; 
                                 
                                 
                                 ; ***** PORTH ************************
                                 ; PORTH - PORT H Data Register
                                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                                 .equ	PH0	= 0	; For compatibility
                                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                                 .equ	PH1	= 1	; For compatibility
                                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                                 .equ	PH2	= 2	; For compatibility
                                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                                 .equ	PH3	= 3	; For compatibility
                                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                                 .equ	PH4	= 4	; For compatibility
                                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                                 .equ	PH5	= 5	; For compatibility
                                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                                 .equ	PH6	= 6	; For compatibility
                                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                                 .equ	PH7	= 7	; For compatibility
                                 
                                 ; DDRH - PORT H Data Direction Register
                                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                                 
                                 ; PINH - PORT H Input Pins
                                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                                 
                                 
                                 ; ***** PORTJ ************************
                                 ; PORTJ - PORT J Data Register
                                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                                 .equ	PJ0	= 0	; For compatibility
                                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                                 .equ	PJ1	= 1	; For compatibility
                                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                                 .equ	PJ2	= 2	; For compatibility
                                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                                 .equ	PJ3	= 3	; For compatibility
                                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                                 .equ	PJ4	= 4	; For compatibility
                                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                                 .equ	PJ5	= 5	; For compatibility
                                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                                 .equ	PJ6	= 6	; For compatibility
                                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                                 .equ	PJ7	= 7	; For compatibility
                                 
                                 ; DDRJ - PORT J Data Direction Register
                                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                                 
                                 ; PINJ - PORT J Input Pins
                                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                                 
                                 
                                 ; ***** PORTK ************************
                                 ; PORTK - PORT K Data Register
                                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                                 .equ	PK0	= 0	; For compatibility
                                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                                 .equ	PK1	= 1	; For compatibility
                                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                                 .equ	PK2	= 2	; For compatibility
                                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                                 .equ	PK3	= 3	; For compatibility
                                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                                 .equ	PK4	= 4	; For compatibility
                                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                                 .equ	PK5	= 5	; For compatibility
                                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                                 .equ	PK6	= 6	; For compatibility
                                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                                 .equ	PK7	= 7	; For compatibility
                                 
                                 ; DDRK - PORT K Data Direction Register
                                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                                 
                                 ; PINK - PORT K Input Pins
                                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                                 
                                 
                                 ; ***** PORTL ************************
                                 ; PORTL - PORT L Data Register
                                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                                 .equ	PL0	= 0	; For compatibility
                                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                                 .equ	PL1	= 1	; For compatibility
                                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                                 .equ	PL2	= 2	; For compatibility
                                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                                 .equ	PL3	= 3	; For compatibility
                                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                                 .equ	PL4	= 4	; For compatibility
                                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                                 .equ	PL5	= 5	; For compatibility
                                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                                 .equ	PL6	= 6	; For compatibility
                                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                                 .equ	PL7	= 7	; For compatibility
                                 
                                 ; DDRL - PORT L Data Direction Register
                                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                                 
                                 ; PINL - PORT L Input Pins
                                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_5 **************
                                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                                 
                                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                                 .equ	ICF5	= 5	; Input Capture Flag 5
                                 
                                 ; TCCR5A - Timer/Counter5 Control Register A
                                 .equ	WGM50	= 0	; Waveform Generation Mode
                                 .equ	WGM51	= 1	; Waveform Generation Mode
                                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR5B - Timer/Counter5 Control Register B
                                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                                 .equ	WGM52	= 3	; Waveform Generation Mode
                                 .equ	WGM53	= 4	; Waveform Generation Mode
                                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                                 
                                 ; TCCR5C - Timer/Counter 5 Control Register C
                                 .equ	FOC5C	= 5	; Force Output Compare 5C
                                 .equ	FOC5B	= 6	; Force Output Compare 5B
                                 .equ	FOC5A	= 7	; Force Output Compare 5A
                                 
                                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                                 
                                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                                 .equ	ICF4	= 5	; Input Capture Flag 4
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	WGM40	= 0	; Waveform Generation Mode
                                 .equ	WGM41	= 1	; Waveform Generation Mode
                                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                                 .equ	WGM42	= 3	; Waveform Generation Mode
                                 .equ	WGM43	= 4	; Waveform Generation Mode
                                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	FOC4C	= 5	; Force Output Compare 4C
                                 .equ	FOC4B	= 6	; Force Output Compare 4B
                                 .equ	FOC4A	= 7	; Force Output Compare 4A
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW00	= 0	; Wait state select bit lower page
                                 .equ	SRW01	= 1	; Wait state select bit lower page
                                 .equ	SRW10	= 2	; Wait state select bit upper page
                                 .equ	SRW11	= 3	; Wait state select bit upper page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRUSART2	= 1	; Power Reduction USART2
                                 .equ	PRUSART3	= 2	; Power Reduction USART3
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                                 ;.equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 .equ	ADC6D	= 6	; 
                                 .equ	ADC7D	= 7	; 
                                 
                                 ; DIDR2 - Digital Input Disable Register
                                 .equ	ADC8D	= 0	; 
                                 .equ	ADC9D	= 1	; 
                                 .equ	ADC10D	= 2	; 
                                 .equ	ADC11D	= 3	; 
                                 .equ	ADC12D	= 4	; 
                                 .equ	ADC13D	= 5	; 
                                 .equ	ADC14D	= 6	; 
                                 .equ	ADC15D	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** USART2 ***********************
                                 ; UDR2 - USART I/O Data Register
                                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR2A - USART Control and Status Register A
                                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                                 .equ	U2X2	= 1	; Double the USART transmission speed
                                 .equ	UPE2	= 2	; Parity Error
                                 .equ	DOR2	= 3	; Data overRun
                                 .equ	FE2	= 4	; Framing Error
                                 .equ	UDRE2	= 5	; USART Data Register Empty
                                 .equ	TXC2	= 6	; USART Transmitt Complete
                                 .equ	RXC2	= 7	; USART Receive Complete
                                 
                                 ; UCSR2B - USART Control and Status Register B
                                 .equ	TXB82	= 0	; Transmit Data Bit 8
                                 .equ	RXB82	= 1	; Receive Data Bit 8
                                 .equ	UCSZ22	= 2	; Character Size
                                 .equ	TXEN2	= 3	; Transmitter Enable
                                 .equ	RXEN2	= 4	; Receiver Enable
                                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR2C - USART Control and Status Register C
                                 .equ	UCPOL2	= 0	; Clock Polarity
                                 .equ	UCSZ20	= 1	; Character Size
                                 .equ	UCSZ21	= 2	; Character Size
                                 .equ	USBS2	= 3	; Stop Bit Select
                                 .equ	UPM20	= 4	; Parity Mode Bit 0
                                 .equ	UPM21	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL20	= 6	; USART Mode Select
                                 .equ	UMSEL21	= 7	; USART Mode Select
                                 
                                 ; UBRR2H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR2L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART3 ***********************
                                 ; UDR3 - USART I/O Data Register
                                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR3A - USART Control and Status Register A
                                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                                 .equ	U2X3	= 1	; Double the USART transmission speed
                                 .equ	UPE3	= 2	; Parity Error
                                 .equ	DOR3	= 3	; Data overRun
                                 .equ	FE3	= 4	; Framing Error
                                 .equ	UDRE3	= 5	; USART Data Register Empty
                                 .equ	TXC3	= 6	; USART Transmitt Complete
                                 .equ	RXC3	= 7	; USART Receive Complete
                                 
                                 ; UCSR3B - USART Control and Status Register B
                                 .equ	TXB83	= 0	; Transmit Data Bit 8
                                 .equ	RXB83	= 1	; Receive Data Bit 8
                                 .equ	UCSZ32	= 2	; Character Size
                                 .equ	TXEN3	= 3	; Transmitter Enable
                                 .equ	RXEN3	= 4	; Receiver Enable
                                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR3C - USART Control and Status Register C
                                 .equ	UCPOL3	= 0	; Clock Polarity
                                 .equ	UCSZ30	= 1	; Character Size
                                 .equ	UCSZ31	= 2	; Character Size
                                 .equ	USBS3	= 3	; Stop Bit Select
                                 .equ	UPM30	= 4	; Parity Mode Bit 0
                                 .equ	UPM31	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL30	= 6	; USART Mode Select
                                 .equ	UMSEL31	= 7	; USART Mode Select
                                 
                                 ; UBRR3H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR3L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                                 .equ	IOEND	= 0x01ff
                                 .equ	SRAM_START	= 0x0200
                                 .equ	SRAM_SIZE	= 8192
                                 .equ	RAMEND	= 0x21ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 262144
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1f000
                                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1efff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0x1fe00
                                 .equ	SECONDBOOTSTART	= 0x1fc00
                                 .equ	THIRDBOOTSTART	= 0x1f800
                                 .equ	FOURTHBOOTSTART	= 0x1f000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                                 
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; COMP2121 Monorail Project
                                 ;
                                   
                                 .include "m2560def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 .include "lcd_def.inc"
                                 
                                  * lcdmacros.inc
                                  *
                                  * Created: 04/10/2018 15:40:13
                                  * Author: Zahid
                                  */ 
                                 
                                 .equ LCD_CLR_DISP   = 0b00000001 ; clear lcd screen
                                 .equ LCD_MOVE_HOME  = 0b10000000 ; move cursor back to start
                                 .equ LCD_SECOND_ROW = 0b10101000 ; move cursor to start of second row
                                 
                                  .macro do_lcd_command
                                 	ldi r16, @0
                                 	rcall lcd_command
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro do_lcd_data
                                 	ldi r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro clear_display
                                 	do_lcd_command 0b00000001	; clear display
                                 	do_lcd_command 0b00000110	; increment, no display shift
                                 	do_lcd_command 0b00001111	; Cursor on, blink on
                                 .endm
                                 
                                 .macro print_direct
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro print_char
                                 	mov r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro print
                                 	mov r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro print_ascii
                                 	ldi r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro print_bin
                                 	ldi r16, '0'
                                 	add r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro print_binary
                                 	ldi r16, '0'
                                 	add r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endm
                                 
                                 .macro print_string
                                 	ldi zl, low(@0<<1)
                                 	ldi zh, high(@0<<1)
                                 	rcall do_lcd_string
                                 .include "macros.inc"
                                 
                                 ; Macros for COMP2121 project
                                 ;
                                 
                                 
                                  .macro div10
                                 	ldi temp, 26		; 256 / 10 
                                 	mul @0, temp		; result in r1
                                 .endm
                                 
                                 .macro mul10
                                 	push temp
                                 	mov temp, @0
                                 	lsl temp
                                 	mov r1, temp
                                 	lsl temp
                                 	lsl temp
                                 	add r1, temp
                                 	pop temp
                                 .endm
                                 
                                 .macro clear
                                 	ldi yl, low(@0)
                                 	ldi yh, high(@0)
                                 	clr temp
                                 	st y+, temp	
                                 	st y, temp
                                 .endmacro
                                 
                                 .macro clearb
                                 	ldi yl, low(@0)
                                 	ldi yh, high(@0)
                                 	clr temp
                                 	st y, temp
                                 .endmacro
                                 
                                 .macro rotatel
                                 	clc
                                 	rol @0
                                 	rol @1
                                 .endm
                                 
                                 .macro rotater
                                 	clc
                                 	ror @1
                                 	ror @0
                                 .endm
                                 
                                 .macro mul10w ; numl, numh
                                 	push temp
                                 	push temp2
                                 
                                 	rotatel @0, @1	; 2a
                                 	mov temp, @0
                                 	mov temp2, @1
                                 
                                 	rotatel @0, @1	; 8a
                                 	rotatel @0, @1	
                                 
                                 	add @0, temp	; 10a
                                 	adc @1, temp2
                                 
                                 	pop temp2
                                 	pop temp
                                 .endm
                                 
                                 .macro div4w ; numl, numh
                                 	rotater @0, @1
                                 	rotater @0, @1
                                 .endm
                                 
                                  .macro div10w ; numl, numh
                                 	push temp
                                 	push resl
                                 	push resh
                                 
                                 	ldi temp, 26		; 256 / 10 
                                 	mul @1, temp		; result in r1
                                 
                                 	mov resl, r0
                                 	mov resh, r1 
                                 
                                 	mul @0, temp
                                 	add resl, r1
                                 	adc resh, zero
                                 		
                                 	mov @0, resl
                                 	mov @1, resh
                                 
                                 	pop resh
                                 	pop resl
                                 	pop temp
                                 
                                 .def sigstop = r9
                                 .def stopped = r10
                                 .def col   = r11
                                 .def row   = r12
                                 .def alpha = r13
                                 .def digit = r14
                                 .def zero  = r3
                                 
                                 .def data  = r16
                                 .def temp  = r17
                                 .def temp2 = r18
                                 .def temp3 = r19
                                 .def temp4  = r20
                                 
                                 .def count = r21
                                 .def mask  = r22
                                 .def index = r23
                                 
                                 .def numl  = r24
                                 .def numh  = r25
                                 
                                 
                                 .equ MAX_NAME_LEN  = 11
                                 .equ MOTOR_SPEED   = 60
                                 .equ PWM_INCREMENT = 2
                                 .equ LED_PATTERN   = 0b00010001
                                 .equ TRUE_MASK     = 0b00000001
                                 
                                 
                                 .dseg
000200                           Status:		   .byte 2	 ; keeps track of the monorail status and what to show on the lcd
                                 
000202                           KeyPressed:	   .byte 4	 ; stores the ascii of the last pushed button
                                 						 ; second byte stores the corresponding letter for digits
                                 						 ; third  byte stores previous key pushed
                                 						 ; fourth byte stores number of times same key pushed
                                 
000206                           DebounceFlag:  .byte 1   ; flag to be checked for debouncing, clear by timer1 ovf
                                 
000207                           TempCounter:   .byte 2	 ; temporary counter used to determine if one second has passed
000209                           SecondCounter: .byte 2	 ; keeps track of the number of seconds that have passed
00020b                           Revolutions:   .byte 2	 ; number of time a hole passes the laser
                                 
00020d                           StationCount:  .byte 1   ; number of stations specified
00020e                           StationNames:  .byte 110 ; array of the station names
00027c                           TravelTimes:   .byte 10  ; array of travel times between stations
000286                           StopTime:      .byte 1	 ; single byte stop time
                                 
                                 .macro clear_globals
                                 	clear TempCounter  
                                 	clear SecondCounter
                                 	clear Revolutions 
                                 	 
                                 	clearb StationCount
                                 	clearb StopTime
                                 
                                 	clear KeyPressed
                                 	clear KeyPressed+2
                                 .endm
                                 .macro toggle
                                 	ldi temp, TRUE_MASK
                                 	eor @0, temp
                                 .endm
                                 
                                 .cseg
                                 .org 0x00
000000 940c 04b4                 jmp RESET		; interrupt vector for RESET
000002 940c 0505                 jmp EXT_INT0	; interrupt vector for External Interrupt 0
000004 940c 0510                 jmp EXT_INT1	; interrupt vector for External Interrupt 1
000006 940c 051b                 jmp EXT_INT2	; interrupt vector for External Interrupt 2
                                 
                                 .org OVF1addr	; OVF1addr is the address of Timer1 Overflow Interrupt Vector
000028 940c 0557                 jmp TIMER1_OVF	; interrupt handler for Timer1 overflow.	
                                 .org OVF0addr	; this is after OVF1addr
00002e 940c 052f                 jmp TIMER0_OVF	; interrupt handler for Timer0 overflow.	
                                 
                                 .include "delay.asm"
                                 
                                  * delay.asm
                                  *
                                  * Created: 04/10/2018 15:12:34
                                  * Author: Zahid
                                  */ 
                                 
                                  ;	if the debounce flag is set, carry bit will be set
                                  ;	and should branch to the given addr. Otherwise, if 
                                  ;	flag is not set, carry is cleared, the flag will be
                                  ;	set and timer 1 enabled
                                  .macro debounce 
                                 	rcall check_debounce_flag	
                                 	brcs @0
                                 .endm
                                 
                                 .macro wait
                                 	push count
                                 	mov count, @0
                                 	rcall wait_for_count
                                 	pop count
                                 .endm
                                 
                                 .macro wait_3s
                                 	push count
                                 	ldi count, 3
                                 	rcall wait_for_count
                                 	pop count
                                 .endm
                                 
                                 .macro wait_5s
                                 	push count
                                 	ldi count, 5
                                 	rcall wait_for_count
                                 	pop count
                                 .endm
                                 
                                  ; 4 cycles per iteration - setup/call-return overhead
                                 .equ F_CPU = 16000000
                                 .equ DELAY_1MS = F_CPU / 4 / 1000 - 4
                                 
                                 .cseg
                                 sleep_1ms:
000030 938f                      	push r24
000031 939f                      	push r25
000032 e09f                      	ldi r25, high(DELAY_1MS)
000033 e98c                      	ldi r24, low(DELAY_1MS)
                                 delayloop_1ms:
000034 9701                      	sbiw r25:r24, 1
000035 f7f1                      	brne delayloop_1ms
000036 919f                      	pop r25
000037 918f                      	pop r24
000038 9508                      	ret
                                 
                                 sleep_5ms:
000039 dff6                      	rcall sleep_1ms
00003a dff5                      	rcall sleep_1ms
00003b dff4                      	rcall sleep_1ms
00003c dff3                      	rcall sleep_1ms
00003d dff2                      	rcall sleep_1ms
00003e 9508                      	ret
                                 
                                 sleep_10ms:
00003f dff9                      	rcall sleep_5ms
000040 dff8                      	rcall sleep_5ms
000041 9508                      	ret
                                 
                                 sleep_25ms:
000042 dff6                      	rcall sleep_5ms
000043 dff5                      	rcall sleep_5ms
000044 dff4                      	rcall sleep_5ms
000045 dff3                      	rcall sleep_5ms
000046 dff2                      	rcall sleep_5ms
000047 9508                      	ret
                                 
                                 sleep_100ms:
000048 dff9                      	rcall sleep_25ms
000049 dff8                      	rcall sleep_25ms
00004a dff7                      	rcall sleep_25ms
00004b dff6                      	rcall sleep_25ms
00004c 9508                      	ret
                                 	
                                 ;
                                 ;	functions to handle debouncing
                                 ;
                                 check_debounce_flag:
00004d 931f                      	push temp
                                 
00004e 9110 0206                 	lds temp, DebounceFlag
000050 3010                      	cpi temp, 0
000051 f011                      	breq enable_timer1
                                 	
000052 9408                      	sec
000053 c007                      	rjmp end_db_flag
                                 	
                                 enable_timer1:
000054 e011                      	ldi temp, 1
000055 9310 0206                 	sts DebounceFlag, temp	
                                 
000057 e011                      	ldi temp, (1<<TOIE1)	; this enables timer1
000058 9310 006f                 	sts TIMSK1, temp
00005a 9488                      	clc	
                                 
                                 end_db_flag:
00005b 911f                      	pop temp
00005c 9508                      	ret
                                 	
                                 
                                 ;
                                 ;	waiting functions
                                 ;
                                 wait_for_count:
00005d 935f                      	push count
00005e 936f                      	push mask
00005f 938f                      	push numl
000060 939f                      	push numh
000061 931f                      	push temp
                                 
000062 9180 0207                 	lds numl, TempCounter		; save initial values
000064 9190 0208                 	lds numh, TempCounter+1
000066 9160 0209                 	lds mask, SecondCounter
                                 
                                 wait_loop:
000068 9110 0209                 	lds temp, SecondCounter		; check if count seconds have passed
00006a 1b16                      	sub temp, mask
00006b 1715                      	cp	temp, count
00006c f3d8                      	brlo wait_loop
                                 
00006d 9110 0207                 	lds temp, TempCounter		; then check if tempcounter is the same
00006f 1718                      	cp	temp, numl 				; so that exactly count seconds have passed
000070 9110 0208                 	lds temp, TempCounter+1
000072 0719                      	cpc temp, numh
000073 f3a0                      	brlo wait_loop				
                                 
                                 wait_end:
000074 911f                      	pop temp
000075 919f                      	pop numh
000076 918f                      	pop numl
000077 916f                      	pop mask
000078 915f                      	pop count
000079 9508                      	ret
                                 
                                 
                                 
                                 wait_with_interrupt:
00007a 935f                      	push count
00007b 936f                      	push mask
00007c 938f                      	push numl
00007d 939f                      	push numh
00007e 931f                      	push temp
                                 
00007f 9180 0207                 	lds numl, TempCounter		; save initial values
000081 9190 0208                 	lds numh, TempCounter+1
000083 9160 0209                 	lds mask, SecondCounter
                                 
                                 wwi_loop:
000085 d109                      	rcall check_keypad
                                 	
000086 9100 0202                 	lds data, KeyPressed
000088 3203                      	cpi data, '#'
000089 f071                      	breq breakdown
                                 
00008a 14a3                      	cp stopped, zero
00008b f7c9                      	brne wwi_loop
                                 
00008c 9110 0209                 	lds temp, SecondCounter		; check if count seconds have passed
00008e 1b16                      	sub temp, mask
00008f 1715                      	cp	temp, count
000090 f2b8                      	brlo wait_loop
                                 
000091 9110 0207                 	lds temp, TempCounter		; then check if tempcounter is the same
000093 1718                      	cp	temp, numl 				; so that exactly count seconds have passed
000094 9110 0208                 	lds temp, TempCounter+1
000096 0719                      	cpc temp, numh
000097 f280                      	brlo wait_loop				
                                 
                                 breakdown:
000098 dfb4
000099 f358                      	debounce wwi_loop
                                 
00009a e011
00009b 26a1                      	toggle stopped
                                 
                                 
                                 
00009c cfe8                      	rjmp wwi_loop
                                 
                                 	
                                 
                                 wwi_end:
00009d 911f                      	pop temp
00009e 919f                      	pop numh
00009f 918f                      	pop numl
0000a0 916f                      	pop mask
0000a1 915f                      	pop count
                                 .include "lcd.asm"
0000a2 9508                      
                                  * lcd.asm
                                  *
                                  *  Created: 04/10/2018 15:11:51
                                  *   Author: Zahid
                                  */ 
                                 
                                 
                                 .equ LCD_RS = 7
                                 .equ LCD_E = 6
                                 .equ LCD_RW = 5
                                 .equ LCD_BE = 4
                                 
                                 .macro lcd_set
                                 	sbi PORTA, @0
                                 .endmacro
                                 .macro lcd_clr
                                 	cbi PORTA, @0
                                 .endmacro
                                 
                                 .cseg
                                 ; Send a command to the LCD (r16)
                                 lcd_command:
0000a3 bb01                      	out PORTF, r16
0000a4 0000                      	nop
0000a5 9a16                      	lcd_set LCD_E
0000a6 0000                      	nop
0000a7 0000                      	nop
0000a8 0000                      	nop
0000a9 9816                      	lcd_clr LCD_E
0000aa 0000                      	nop
0000ab 0000                      	nop
0000ac 0000                      	nop
0000ad 9508                      	ret
                                 
                                 lcd_data:
0000ae bb01                      	out PORTF, r16
0000af 9a17                      	lcd_set LCD_RS
0000b0 0000                      	nop
0000b1 0000                      	nop
0000b2 0000                      	nop
0000b3 9a16                      	lcd_set LCD_E
0000b4 0000                      	nop
0000b5 0000                      	nop
0000b6 0000                      	nop
0000b7 9816                      	lcd_clr LCD_E
0000b8 0000                      	nop
0000b9 0000                      	nop
0000ba 0000                      	nop
0000bb 9817                      	lcd_clr LCD_RS
0000bc 9508                      	ret
                                 
                                 lcd_wait:
0000bd 930f                      	push r16
0000be 2700                      	clr r16
0000bf bb00                      	out DDRF, r16
0000c0 bb01                      	out PORTF, r16
0000c1 9a15                      	lcd_set LCD_RW
                                 lcd_wait_loop:
0000c2 0000                      	nop
0000c3 9a16                      	lcd_set LCD_E
0000c4 0000                      	nop
0000c5 0000                      	nop
0000c6 0000                          nop
0000c7 b10f                      	in r16, PINF
0000c8 9816                      	lcd_clr LCD_E
0000c9 fd07                      	sbrc r16, 7
0000ca cff7                      	rjmp lcd_wait_loop
0000cb 9815                      	lcd_clr LCD_RW
0000cc ef0f                      	ser r16
0000cd bb00                      	out DDRF, r16
0000ce 910f                      	pop r16
                                 .include "print_number.asm"
0000cf 9508                      
                                  * print_number.asm
                                  *
                                  *  Created: 19/10/2018 14:19:00
                                  *   Author: Zahid
                                  */ 
                                 
                                 .cseg
                                 ;
                                 ; Prints out a max 5 digit number on to the LCD
                                 ;
                                 do_lcd_number:
0000d0 931f                      	push temp
0000d1 935f                      	push count
0000d2 92ef                      	push digit
                                 
0000d3 2711                      	clr temp
0000d4 e054                      	ldi count, 4				; two byte numbers have 5 digits max, 65536
                                 
                                 digit_loop:						; get digit at 10^4, then 10^3...
0000d5 d014                      	rcall get_place_digit		; and print them out in that order
0000d6 16e1                      	cp  digit, temp				; don't print the leading zeros
0000d7 f029                      	breq next_place				; temp will not be 0, when the first non-zero is encountered
                                 
                                 show_digit:
0000d8 e310                      	ldi temp, '0'
0000d9 0d1e                      	add temp, digit			; digit = get_place_digit(count)		
0000da 2f01
0000db dfd2
0000dc dfe0                      	print temp
                                 
                                 next_place:
0000dd 955a                      	dec count
0000de 3050                      	cpi count, 0
0000df f7ac                      	brge digit_loop 
                                 
0000e0 3010                      	cpi temp, 0					; if number is zero, just print a zero
0000e1 f421                      	brne lcd_number_end
0000e2 e310                      	ldi temp, '0'
0000e3 2f01
0000e4 dfc9
0000e5 dfd7                      	print temp	
                                 
                                 lcd_number_end:
0000e6 90ef                      	pop digit
0000e7 915f                      	pop count
0000e8 911f                      	pop temp
0000e9 9508                      	ret
                                 
                                 ;
                                 ; Gets the decimal digit from the current value
                                 ; in the place specified by col, 10^col place
                                 get_place_digit:
0000ea 931f                      	push temp
0000eb 932f                      	push temp2
0000ec 933f                      	push temp3
0000ed 934f                      	push temp4
0000ee 935f                      	push count
                                 
0000ef 24ee                      	clr digit
0000f0 2733                      	clr temp3				; use prow and pcol to subtract from num
0000f1 2744                      	clr temp4				; calculate the place value
0000f2 9533                      	inc temp3				; if hundreds place, do 1*10*10
                                 
                                 place_loop:					
0000f3 3050                      	cpi count, 0
0000f4 f099                      	breq sub_loop
0000f5 955a                      	dec count
0000f6 931f
0000f7 932f
0000f8 9488
0000f9 1f33
0000fa 1f44
0000fb 2f13
0000fc 2f24
0000fd 9488
0000fe 1f33
0000ff 1f44
000100 9488
000101 1f33
000102 1f44
000103 0f31
000104 1f42
000105 912f
000106 911f                      	mul10w temp3, temp4		; mul10w uses temp and temp2
000107 cfeb                      	rjmp place_loop
                                 
                                 sub_loop:
000108 1783                      	cp  numl, temp3
000109 0794                      	cpc numh, temp4
00010a f024                      	brlt place_end	
                                 
00010b 94e3                      	inc digit				; count how many times place value can be subtracted
                                 
00010c 1b83                      	sub numl, temp3			; for hundreds, count num-100, until num < 100
00010d 0b94                      	sbc numh, temp4			; to get the digits in the hundredth place
00010e cff9                      	rjmp sub_loop 
                                 
                                 place_end:
00010f 915f                      	pop count
000110 914f                      	pop temp4
000111 913f                      	pop temp3
000112 912f                      	pop temp2
000113 911f                      	pop temp
                                 .include "print_string.asm"
000114 9508                      
                                  * print_string.asm
                                  */ 
                                  
                                 ;
                                 ; Prints out a string on to the LCD
                                 ;
                                 do_lcd_string:
000115 93ef                      	push zl
000116 93ff                      	push zh
000117 930f                      	push data
                                 
                                 char_loop:
000118 9105                      	lpm data, z+				; get character from string
000119 3000                      	cpi data, 0					; if character is null
00011a f049                      	breq lcd_string_end			; then return
                                 		
00011b 320f                      	cpi data, '/'				; if character is a flash
00011c f421                      	brne output_char			; print on next line
00011d ec00
00011e df84
00011f df9d                      	do_lcd_command 0b11000000
000120 cff7                      	rjmp char_loop
                                 
                                 output_char:					; print character to lcd
000121 df8c
000122 df9a                      	print_direct
000123 cff4                      	rjmp char_loop
                                 
                                 lcd_string_end:
000124 910f                      	pop data
000125 91ff                      	pop zh
000126 91ef                      	pop zl
000127 9508                      	ret
                                 
                                 
                                 ;
                                 ;	Prints out a station name
                                 ;
                                 do_lcd_stn_name:
000128 93af                      	push xl
000129 93bf                      	push xh
00012a 930f                      	push data
00012b 935f                      	push count
                                 
00012c 2755                      	clr count
                                 
                                 char_loop_stn:
00012d 910d                      	ld data, x+					; get character from string
00012e 3000                      	cpi data, 0					; if character is null
00012f f031                      	breq lcd_stn_name_end		; then return
                                 			
000130 df7d
000131 df8b                      	print_direct				; print character to lcd
000132 9553                      	inc count
000133 305b                      	cpi count, MAX_NAME_LEN
000134 f009                      	breq lcd_stn_name_end
000135 cff7                      	rjmp char_loop_stn
                                 
                                 lcd_stn_name_end:
000136 915f                      	pop count
000137 910f                      	pop data
000138 91bf                      	pop xh
000139 91af                      	pop xl
                                 .include "keypad.asm"
00013a 9508                      
                                 ;	Gets keypad input
                                 ;
                                 
                                 .equ PORTLDIR = 0xF0
                                 .equ INITCOLMASK = 0xEF
                                 .equ INITROWMASK = 0x01
                                 .equ ROWMASK = 0x0F
                                 
                                 ; KeyPressed Var
                                 ; first  byte stores the ascii of the last pushed button
                                 ; second byte stores the corresponding letter for digits
                                 ; third  byte stores previous key pushed
                                 ; fourth byte stores number of times same key pushed
                                 
                                 .cseg
                                 ;
                                 ;	scan the keypad u
                                 ;
                                 get_keypad_alpha:
00013b 931f                      	push temp
00013c 932f                      	push temp2
00013d 936f                      	push mask
00013e 92ef                      	push digit
00013f 935f                      	push count
000140 937f                      	push index
                                 	
000141 d037                      	rcall get_keypad_input
000142 9160 0202                 	lds mask,  KeyPressed	; get the digit pressed	
000144 90e0 0204                 	lds digit, KeyPressed+2	; get the previous digit pressed
000146 9150 0205                 	lds count, KeyPressed+3	; the number of times this digit was pushed in a row
                                 
000148 2722                      	clr temp2				; no additional offset
                                 
000149 3461                      	cpi mask, 'A'
00014a f414                      	brge set_space
00014b 3362                      	cpi mask, '2'			
00014c f424                      	brge check_repeat		; only digits 2 and above have letters		
                                 
                                 set_space:
00014d e270                      	ldi index, ' '			; just set put in a space for everything else
00014e 9370 0203                 	sts KeyPressed+1, index 
000150 c021                      	rjmp end_keypad_alpha
                                 
                                 check_repeat:
000151 156e                      	cp mask, digit			; previous digit was different so reset count
000152 f029                      	breq increment_repeat	; otherwise increment it
                                 
000153 2755                      	clr count	
                                 	
000154 3368                      	cpi mask, '8'
000155 f084                      	brlt set_alpha
000156 e021                      	ldi temp2, 1			; add one to additional offset since 7 has 4 letters
000157 c00e                      	rjmp set_alpha			; for digits 8 and 9
                                 
                                 increment_repeat:
000158 9553                      	inc count
                                 
000159 3367                      	cpi mask, '7'			; have to mod count since count is the offset from first letter
00015a f024                      	brlt mod_count_3		; everything below 7 has 3 letters
00015b f039                      	breq mod_count_4		; 7 has 4 letters
                                 	
00015c e021                      	ldi temp2, 1			; add one to additional offset
00015d 3369                      	cpi mask, '9'			; 9 also has 4 letters
00015e f021                      	breq mod_count_4
                                 
                                 mod_count_3:
00015f 3053                      	cpi count, 3			; count % 3
000160 f02c                      	brlt set_alpha
000161 5053                      	subi count, 3
000162 c003                      	rjmp set_alpha
                                 
                                 mod_count_4:				; count % 4
000163 3054                      	cpi count, 4
000164 f00c                      	brlt set_alpha
000165 5054                      	subi count, 4	
                                 	
                                 set_alpha:
000166 9350 0205                 	sts KeyPressed+3, count
                                 
000168 2f76                      	mov index, mask			; this converts the digit ascii to desired letter ascii
000169 5370                      	subi index, '0'			; and saves it to KeyPressed+1
00016a 0f77                      	lsl index				; index = (mask - '0') * 2 + 11 + offsets + mask
00016b e01b                      	ldi temp, 11			; where index is the letter ascii and mask the digit ascii
00016c 0f71                      	add index, temp
00016d 0f72                      	add index, temp2
00016e 0f75                      	add index, count
00016f 0f76                      	add index, mask
                                 
000170 9370 0203                 	sts KeyPressed+1, index 
                                 
                                 end_keypad_alpha:
000172 917f                      	pop index
000173 915f                      	pop count
000174 90ef                      	pop digit
000175 916f                      	pop mask
000176 912f                      	pop temp2
000177 911f                      	pop temp
000178 9508                      	ret
                                 
                                 
                                 ;
                                 ;	scans the keypad until a button is pushed, then returns
                                 ;
                                 get_keypad_input:
000179 931f                      	push temp
00017a 930f                      	push data
00017b 937f                      	push index
                                 
00017c 9170 0202                 	lds index, KeyPressed	; record the previous key
00017e 2f67                      	mov mask, index			; for saving later
                                 
                                 key_loop:
00017f d00f                      	rcall check_keypad		; loop until a key is pushed
000180 9100 0202                 	lds data, KeyPressed
000182 3000                      	cpi data, 0
000183 f3d9                      	breq key_loop
                                 
000184 1707                      	cp  data, index			; compare the key pushed with previous	
000185 f419                      	brne save_key_press
                                 
000186 dec1                      	rcall sleep_100ms		; if it's the same, do debouncing
000187 e070                      	ldi index, 0			; set previous key to zero, so debounce happens once
000188 cff6                      	rjmp key_loop
                                 
                                 save_key_press:		
000189 9360 0204                 	sts KeyPressed+2, mask	; store the previous key 
                                 
                                 end_keypad_input:
00018b 917f                      	pop index
00018c 910f                      	pop data
00018d 911f                      	pop temp
00018e 9508                      	ret
                                 
                                 
                                 ;
                                 ;	scan the keypad once for a button push
                                 ;
                                 check_keypad:
00018f 931f                      	push temp
000190 932f                      	push temp2
000191 936f                      	push mask
000192 92bf                      	push col
000193 92cf                      	push row
                                 
000194 2711                      	clr temp
000195 9310 0202                 	sts KeyPressed, temp
                                 
000197 ee6f                      	ldi mask, INITCOLMASK	; initial column mask	
000198 24bb                      	clr col					; initial column
                                 
                                 colloop:
000199 9360 010b                 	sts PORTL, mask			; set column to mask value (sets column 0 off)
                                 	
00019b ef1f                      	ldi temp, 0xFF			; implement a delay so the hardware can stabilize
                                 	keypad_delay:
00019c 951a                      	dec temp
00019d f7f1                      	brne keypad_delay
                                 
00019e 9110 0109                 	lds temp, PINL			; read PORTL. Cannot use in 
0001a0 701f                      	andi temp, ROWMASK		; read only the row bits
0001a1 301f                      	cpi temp, ROWMASK		; check if any rows are grounded
0001a2 f069                      	breq nextcol			; if not go to the next column
                                 
0001a3 e061                      	ldi mask, INITROWMASK	; initialise row check
0001a4 24cc                      	clr row					; initial row
                                 
                                 rowloop:
0001a5 2f21                      	mov temp2, temp			; save PINL to check for grounded bit      
0001a6 2326                      	and temp2, mask			; check masked bit
0001a7 f421                      	brne skipconv			; if the result is non-zero, we need to look again
                                 	
0001a8 d015                      	rcall key_to_ascii		; if bit is clear, convert the bitcode
0001a9 9310 0202                 	sts KeyPressed, temp
0001ab c00c                      	rjmp keypad_end			; and return value in KeyPressed
                                 
                                 skipconv:
0001ac 94c3                      	inc row					; else move to the next row
0001ad 0f66                      	lsl mask				; shift the mask to the next bit
0001ae 940c 01a5                 	jmp rowloop          
                                 
                                 nextcol:
0001b0 e013                      	ldi temp, 3     
0001b1 16b1                      	cp  col, temp			; check if we're on the last column
0001b2 f029                      	breq keypad_end			; if so, no buttons were pushed, just return
                                 
0001b3 9408                      	sec						; else shift the column mask: We must set the carry bit
0001b4 1f66                      	rol mask				; and then rotate left by a bit, shifting the carry into
                                 							; bit zero. We need this to make sure all the rows have
                                 							; pull-up resistors
                                 
0001b5 94b3                      	inc col					; increment column value
0001b6 940c 0199                 	jmp colloop				; and check the next column convert function converts the 
                                 							; row and column given to a binary number and also outputs 
                                 							; the value to KeyPressed.
                                 
                                 keypad_end:
0001b8 90cf                      	pop row
0001b9 90bf                      	pop col
0001ba 916f                      	pop mask
0001bb 912f                      	pop temp2
0001bc 911f                      	pop temp
0001bd 9508                      	ret	
                                 
                                 ;
                                 ; Inputs come from registers row and col and output will in the temp register
                                 ; which is then stored in KeyPressed
                                 ;
                                 key_to_ascii:
0001be e013                      	ldi temp, 3				
0001bf 16b1                      	cp col, temp			; if column is 3 we have a letter
0001c0 f059                      	breq letter_keys
                                 
0001c1 16c1                      	cp row, temp			; if row is 3 we have a symbol or 0
0001c2 f069                      	breq symbol_keys
                                 
                                 digit_keys:
0001c3 2d1c                      	mov temp, row			; otherwise we have a number (1-9)
0001c4 0f11                      	lsl temp				; temp = row * 2
0001c5 0d1c                      	add temp, row			; temp = row * 3
0001c6 0d1b                      	add temp, col			; add the column address to get the offset from 1
0001c7 9513                      	inc temp				; add 1. Value of switch is row*3 + col + 1.
                                 
0001c8 e320                      	ldi temp2, '0'
0001c9 0f12                      	add temp, temp2
0001ca 940c 01dd                 	jmp key2ascii_end
                                 	
                                 letter_keys:
0001cc e411                      	ldi temp, 'A'
0001cd 0d1c                      	add temp, row			; increment from 'A' by the row value
0001ce 940c 01dd                 	jmp key2ascii_end
                                 
                                 symbol_keys:
0001d0 2711                      	clr temp
0001d1 16b1                      	cp  col, temp			; check if we have a star, zero or hash
0001d2 f031                      	breq star_key
0001d3 9513                      	inc temp
0001d4 16b1                      	cp  col, temp				
0001d5 f031                      	breq zero_key
                                 
                                 hash_key:
0001d6 e213                      	ldi temp, '#'	
0001d7 940c 01dd                 	jmp key2ascii_end
                                 
                                 star_key:
0001d9 e21a                      	ldi temp, '*'
0001da 940c 01dd                 	jmp key2ascii_end
                                 
                                 zero_key:
0001dc e310                      	ldi temp, '0'
                                 
                                 key2ascii_end:
0001dd de64                      	rcall sleep_25ms
                                 .include "motor.asm"
0001de 9508                      
                                  * motor.asm
                                  *
                                  * Created: 19/10/2018 15:30:58
                                  * Author: Zahid
                                  */ 
                                 
                                 ;
                                 ;	Changes the pwm duty cycle
                                 ;
                                 set_speed:
0001df 936f                      	push mask
0001e0 931f                      	push temp
0001e1 932f                      	push temp2
0001e2 938f                      	push numl
0001e3 939f                      	push numh
0001e4 936f                      	push mask
                                 
0001e5 14a3                      	cp stopped, zero		; 0 is monorail moving, 1 is stop		
0001e6 f019                      	breq move_motor
                                 
                                 stop_motor:
0001e7 9230 009a                 	sts OCR3BL, zero
0001e9 c029                      	rjmp speed_end
                                 
                                 move_motor:
0001ea 9180 020b                 	lds numl, Revolutions	
0001ec 9190 020c                 	lds numh, Revolutions+1
                                 
0001ee 931f
0001ef 932f
0001f0 9488
0001f1 1f88
0001f2 1f99
0001f3 2f18
0001f4 2f29
0001f5 9488
0001f6 1f88
0001f7 1f99
0001f8 9488
0001f9 1f88
0001fa 1f99
0001fb 0f81
0001fc 1f92
0001fd 912f
0001fe 911f                      	mul10w numl, numh
0001ff 9488
000200 9597
000201 9587
000202 9488
000203 9597
000204 9587                      	div4w numl, numh
                                 
000205 9160 009a                 	lds mask, OCR3BL
                                 
000207 e31c                      	ldi temp, MOTOR_SPEED
000208 1781                      	cp numl, temp			; just keep lower byte, assume rps < 255
000209 f02c                      	brlt incr_speed
00020a f041                      	breq speed_end
                                 
                                 decr_speed:
00020b 5062                      	subi mask, PWM_INCREMENT
00020c 9360 009a                 	sts OCR3BL, mask
00020e c004                      	rjmp speed_end
                                 	
                                 incr_speed:
00020f e012                      	ldi temp, PWM_INCREMENT
000210 0f61                      	add mask, temp
000211 9360 009a                 	sts OCR3BL, mask
                                 
                                 speed_end:
000213 916f                      	pop mask
000214 919f                      	pop numh
000215 918f                      	pop numl
000216 912f                      	pop temp2
000217 911f                      	pop temp
000218 9508                      	ret
                                 	
                                 ;
                                 ;	Shows the motor's revolutions per second on the lcd
                                 ;
                                 PrintRevolutions:
000219 938f                      	push numl
00021a 939f                      	push numh
00021b 931f                      	push temp
                                 
00021c e001
00021d de85
00021e de9e                      	do_lcd_command 0b00000001 ; clear display
00021f e006
000220 de82
000221 de9b                      	do_lcd_command 0b00000110 ; increment, no display shift
000222 e00c
000223 de7f
000224 de98                      	do_lcd_command 0b00001100 ; Cursor on, no bar, no blink
                                 
000225 9180 020b                 	lds numl, Revolutions	
000227 9190 020c                 	lds numh, Revolutions+1
                                 
000229 931f
00022a 932f
00022b 9488
00022c 1f88
00022d 1f99
00022e 2f18
00022f 2f29
000230 9488
000231 1f88
000232 1f99
000233 9488
000234 1f88
000235 1f99
000236 0f81
000237 1f92
000238 912f
000239 911f                      	mul10w numl, numh
00023a 9488
00023b 9597
00023c 9587
00023d 9488
00023e 9597
00023f 9587                      	div4w numl, numh
                                 
000240 de8f                      	rcall do_lcd_number
                                 
000241 e0cb
000242 e0d2
000243 2711
000244 9319
000245 8318                      	clear Revolutions
                                 
000246 916f                      	pop mask
000247 911f                      	pop temp
000248 919f                      	pop numh
000249 918f                      	pop numl
                                 .include "user_input.asm"
00024a 9508                      
                                  * user_input.asm
                                  *
                                  * Created: 19/10/2018 16:29:06
                                  */ 
                                 
                                 
                                  .macro get_index_addr
                                  	ldi xl, low(StationNames)
                                 	ldi xh, high(StationNames)
                                 	ldi temp, MAX_NAME_LEN		; length of name string is 11
                                 	mul temp, index
                                 	add xl, r0					; this puts the x pointer to the correct spot to get
                                 	adc xh, r1					; the station name at index	
                                 .endm
                                 
                                 .macro print_stn_name
                                 	get_index_addr
                                 	rcall do_lcd_stn_name
                                 .endm
                                 
                                 .macro set_travel_time_addr
                                 	ldi xl, low(TravelTimes)
                                 	ldi xh, high(TravelTimes)
                                 	add xl, index
                                 	add xh, zero
                                 .endm
                                 
                                 
                                  ;
                                  ;	Prompt for number of stations, max is 10
                                  ;
                                 get_station_count:
00024b 935f                      	push count
00024c 930f                      	push data
00024d 931f                      	push temp
00024e 932f                      	push temp2
                                 
                                 station_count_loop:
00024f e0cd
000250 e0d2
000251 2711
000252 9319
000253 8318                      	clear StationCount
                                 
000254 2755                      	clr count
000255 2711                      	clr temp 
000256 2700                      	clr data
                                 
000257 e001
000258 de4a
000259 de63
00025a e006
00025b de47
00025c de60
00025d e00f
00025e de44
00025f de5d                      	clear_display
000260 eee0
000261 e0f8
000262 deb2                      	print_string PromptStnNum	; ask for user to enter number of station
                                 
                                 check_stn_count:	
000263 df15                      	rcall get_keypad_input
                                 		
000264 9100 0202                 	lds data, KeyPressed		; check the button pushed is valid
000266 3203                      	cpi data, '#'
000267 f0e9                      	breq end_station_count
000268 3401                      	cpi data, 'A'
000269 f72c                      	brge station_count_loop
00026a 320a                      	cpi data, '*'
00026b f319                      	breq station_count_loop	
                                 
                                 
                                 store_stn_count:
                                 
00026c 3052                      	cpi count, 2				; checking if the user has entered more then 1 number
00026d f7ac                      	brge check_stn_count		
                                 
00026e de3f
00026f de4d                      	print_direct				; Print data before saving it
                                 
000270 5300                      	subi data, '0'				; takes away ascii value of data
000271 9120 020d                 	lds temp2, StationCount
000273 931f
000274 2f12
000275 0f11
000276 2e11
000277 0f11
000278 0f11
000279 0e11
00027a 911f                      	mul10 temp2
00027b 0d01                      	add data, r1				; result of mul10 will be in r1
                                 
00027c 300b                      	cpi data, 11				; ensure count is 10 or less
00027d f68c                      	brge station_count_loop
00027e 3000                      	cpi data, 0					; checking if data is equal to 0, and will return 
00027f f279                      	breq station_count_loop
                                 
000280 2f10                      	mov temp, data
000281 9300 020d                 	sts StationCount, data
000283 9553                      	inc count
000284 cfde                      	rjmp check_stn_count		; checks for another key press
                                 	 
                                 end_station_count:
000285 3011                      	cpi temp, 1					; if temp is 1 then only 1 station and that is not allowed
000286 f241                      	breq station_count_loop
000287 3050                      	cpi count, 0
000288 f231                      	breq station_count_loop
                                 
000289 912f                      	pop temp2
00028a 911f                      	pop temp
00028b 910f                      	pop data
00028c 915f                      	pop count
00028d 9508                      	ret
                                 
                                 
                                 
                                  ;
                                  ;	Prompt for names of the stations
                                  ;
                                 get_station_names:
00028e 937f                      	push index
00028f 936f                      	push mask
000290 931f                      	push temp
000291 930f                      	push data
000292 935f                      	push count
000293 92df                      	push alpha
                                 	
000294 e001
000295 de0d
000296 de26
000297 e006
000298 de0a
000299 de23
00029a e00f
00029b de07
00029c de20                      	clear_display
00029d efea
00029e e0f8
00029f de75                      	print_string InstrStnNames
0002a0 e00c
0002a1 de01
0002a2 de1a                      	do_lcd_command 0b00001100	; cursor off
0002a3 935f
0002a4 e053
0002a5 ddb7
0002a6 915f                      	wait_3s
                                 
0002a7 2777                      	clr index
                                 
                                 station_names_loop:  
0002a8 e0ae
0002a9 e0b2
0002aa e01b
0002ab 9f17
0002ac 0da0
0002ad 1db1                      	get_index_addr				; get address of index, puts it in xh:xl
0002ae 9573                      	inc index
                                     
0002af 9110 020d                 	lds temp, StationCount
0002b1 301a                      	cpi temp, 10
0002b2 f0a9                      	breq check_ten
                                 
0002b3 e001
0002b4 ddee
0002b5 de07
0002b6 e006
0002b7 ddeb
0002b8 de04
0002b9 e00f
0002ba dde8
0002bb de01                      	clear_display
0002bc e4e0
0002bd e0f9
0002be de56                      	print_string LabelStation
0002bf e300
0002c0 0f07
0002c1 ddec
0002c2 ddfa                      	print_binary index
0002c3 e4ea
0002c4 e0f9
0002c5 de4f                      	print_string LabelStnEnd
0002c6 2755                      	clr count
0002c7 c02d                      	rjmp name_char_loop
                                 
                                 	check_ten:
0002c8 307a                      		cpi index, 10
0002c9 f4b9                      		brne print_norm
                                 
0002ca e001
0002cb ddd7
0002cc ddf0
0002cd e006
0002ce ddd4
0002cf dded
0002d0 e00f
0002d1 ddd1
0002d2 ddea                      		clear_display
0002d3 e4e0
0002d4 e0f9
0002d5 de3f                      		print_string LabelStation
0002d6 e301                      		ldi data, '1'
0002d7 ddd6
0002d8 dde4                      		print_direct
0002d9 e300                      		ldi data, '0'
0002da ddd3
0002db dde1                      		print_direct
0002dc e4ea
0002dd e0f9
0002de de36                      		print_string LabelStnEnd
0002df 2755                      		clr count
0002e0 c014                      		rjmp name_char_loop
                                 
                                 	print_norm:
0002e1 e001
0002e2 ddc0
0002e3 ddd9
0002e4 e006
0002e5 ddbd
0002e6 ddd6
0002e7 e00f
0002e8 ddba
0002e9 ddd3                      		clear_display
0002ea e4e0
0002eb e0f9
0002ec de28                      		print_string LabelStation
0002ed e300
0002ee 0f07
0002ef ddbe
0002f0 ddcc                      		print_binary index
0002f1 e4ea
0002f2 e0f9
0002f3 de21                      		print_string LabelStnEnd
                                 	
0002f4 2755                      	clr count
                                 
                                 name_char_loop:
0002f5 de45                          rcall get_keypad_alpha
                                 
0002f6 9160 0202                     lds mask, KeyPressed
0002f8 9100 0203                     lds data, KeyPressed+1
                                 		
                                     ; dealing with special keys for input
0002fa 3263                          cpi mask, '#'
0002fb f0b1                          breq next_station_name
0002fc 326a                          cpi mask, '*'
0002fd f051                          breq store_name_char
0002fe 3461                          cpi mask, 'A'
0002ff f7ac                          brge name_char_loop
                                 			
000300 2f00
000301 ddac
000302 ddba                          print_char data				; input was a digit, print the alpha character
000303 2ed0                      	mov alpha, data				; save the print character
000304 e100
000305 dd9d
000306 ddb6                          do_lcd_command 0b00010000	; lets user input until '#' is pressed
000307 cfed                          rjmp name_char_loop
                                 
                                 store_name_char:
000308 92dd                      	st x+, alpha				; store the charater
000309 90d0 0203                 	lds alpha, KeyPressed+1		; change to space for next store
00030b 9553                      	inc count					; count is checking if the name is longer than 10 letters/spaces
00030c 305a                      	cpi count, 10				; checking number of entered characters is more than 10
00030d f021                          breq next_station_name
                                 
00030e e104
00030f dd93
000310 ddac                      	do_lcd_command 0b00010100	; move cursor onto the next space 
000311 cfe3                      	rjmp name_char_loop
                                   
                                 next_station_name:				; if '#' is pressed then we will put a 0 to the end of the name 
000312 923c                      	st x, zero					; to show that it is the end of input
000313 9110 020d                 	lds temp, StationCount
000315 1771                      	cp index, temp			
000316 f009                      	breq end_station_name
000317 cf90                      	rjmp station_names_loop
                                 
                                 end_station_name:
000318 90df                      	pop alpha
000319 915f                      	pop count
00031a 910f                      	pop data
00031b 911f                      	pop temp
00031c 916f                      	pop mask
00031d 917f                      	pop index
00031e 9508                      	ret
                                 
                                 
                                 
                                 ;
                                 ;	Function to recive user input for the station times
                                 ;
                                 get_station_times:
00031f 93cf                      	push yl
000320 93df                      	push yh
000321 935f                      	push count
000322 930f                      	push data
000323 931f                      	push temp
000324 932f                      	push temp2
000325 933f                      	push temp3
000326 937f                      	push index
                                 
000327 e7cc
000328 e0d2
000329 2711
00032a 9319
00032b 8318                      	clear TravelTimes			; zero out the array
00032c e7ce
00032d e0d2
00032e 2711
00032f 9319
000330 8318                      	clear TravelTimes+2
000331 e8c0
000332 e0d2
000333 2711
000334 9319
000335 8318                      	clear TravelTimes+4
000336 e8c2
000337 e0d2
000338 2711
000339 9319
00033a 8318                      	clear TravelTimes+6
00033b e8c4
00033c e0d2
00033d 2711
00033e 9319
00033f 8318                      	clear TravelTimes+8
                                 
000340 e001
000341 dd61
000342 dd7a
000343 e006
000344 dd5e
000345 dd77
000346 e00f
000347 dd5b
000348 dd74                      	clear_display
000349 e2ec
00034a e0f9
00034b ddc9                      	print_string InstrStnTimes	; ask for user to enter time btwn stations
00034c e00c
00034d dd55
00034e dd6e                      	do_lcd_command 0b00001100	; cursor off
00034f 935f
000350 e053
000351 dd0b
000352 915f                      	wait_3s		
                                 	
000353 2777                      	clr index		
                                 
                                 station_times_loop:
000354 e001
000355 dd4d
000356 dd66
000357 e006
000358 dd4a
000359 dd63
00035a e00f
00035b dd47
00035c dd60                      	clear_display				; to print out " time to name1 to name2"
00035d e0ae
00035e e0b2
00035f e01b
000360 9f17
000361 0da0
000362 1db1
000363 ddc4                      	print_stn_name				; print the first station name
000364 e4ee
000365 e0f9
000366 ddae                      	print_string LabelStnTime	; station (n) to
                                 
000367 2f37                      	mov temp3, index
                                 
000368 9573                      	inc index					; if last station, next station is the first
000369 9110 020d                 	lds temp, StationCount
00036b 1771                      	cp  index, temp
00036c f00c                      	brlt print_second_stn
00036d 2777                      	clr index
                                 
                                 	print_second_stn:
00036e e0ae
00036f e0b2
000370 e01b
000371 9f17
000372 0da0
000373 1db1
000374 ddb3                      	print_stn_name				; print the next station name
000375 e30a
000376 dd37
000377 dd45                      	print_ascii ':'				; station (n+1):
                                 	
000378 2f73                      	mov index, temp3
000379 2755                      	clr count					; keeps track of number of inputs
                                 
                                 travel_time_input:	
00037a ddfe                      	rcall get_keypad_input
                                 		
00037b 9100 0202                 	lds data, KeyPressed		; check the button pushed
00037d 3203                      	cpi data, '#'				; hash means input done
00037e f121                      	breq next_stn_time
00037f 3401                      	cpi data, 'A'				; ignore letter and star buttons
000380 f7cc                      	brge travel_time_input
000381 320a                      	cpi data, '*'
000382 f3b9                      	breq travel_time_input
000383 3052                      	cpi count, 2				; maximum of 2 characters allowed
000384 f7ac                      	brge travel_time_input		
                                 
000385 dd28
000386 dd36                      	print_direct				; print the digit before saving the value
000387 e7ac
000388 e0b2
000389 0fa7
00038a 0db3                      	set_travel_time_addr		; move to the index in travel times array
                                 
00038b 5300                      	subi data, '0'				; takes away ascii value to get binary value
00038c 912c                      	ld temp2, x
00038d 931f
00038e 2f12
00038f 0f11
000390 2e11
000391 0f11
000392 0f11
000393 0e11
000394 911f                      	mul10 temp2
000395 0d01                      	add data, r1			
                                 
000396 300b                      	cpi data, 11				; ensure time is 10 or less
000397 f42c                      	brge redo_travel_time
000398 3000                      	cpi data, 0					; minimum time must be 1
000399 f019                      	breq redo_travel_time
                                  
00039a 930c                      	st x, data					; store the travel time 
00039b 9553                      	inc count
00039c cfdd                      	rjmp travel_time_input
                                 
                                 redo_travel_time:
00039d e7ac
00039e e0b2
00039f 0fa7
0003a0 0db3                      	set_travel_time_addr
0003a1 923c                      	st x, zero					; rif time not valid, get user to reinput
0003a2 cfb1                      	rjmp station_times_loop
                                 
                                 next_stn_time:
0003a3 3050                          cpi count, 0				; ensure user has input something
0003a4 f3c1                      	breq redo_travel_time
                                 
0003a5 9573                      	inc index					; continue to next two stations
0003a6 9110 020d                 	lds temp, StationCount		; no more stations
0003a8 1771                      	cp  index, temp
0003a9 f009                          breq end_station_time
0003aa cfa9                      	rjmp station_times_loop
                                 
                                 end_station_time:
0003ab 917f                      	pop index
0003ac 913f                      	pop temp3
0003ad 912f                      	pop temp2
0003ae 911f                      	pop temp
0003af 910f                      	pop data
0003b0 915f                      	pop count
0003b1 91df                      	pop yh
0003b2 91cf                      	pop yl
0003b3 9508                      	ret
                                 
                                 
                                 ;
                                 ; Get Stop Time
                                 ; Asking user for the stop time at all the stations (one stop time for all)
                                 ;
                                 get_stop_time:
0003b4 931f                      	push temp
0003b5 930f                      	push data
0003b6 937f                      	push index
0003b7 93ef                      	push zl
0003b8 93ff                      	push zh
                                 
0003b9 e001
0003ba dce8
0003bb dd01
0003bc e006
0003bd dce5
0003be dcfe
0003bf e00f
0003c0 dce2
0003c1 dcfb                      	clear_display
0003c2 e1e6
0003c3 e0f9
0003c4 dd50                      	print_string InstrStpTime
0003c5 e00c
0003c6 dcdc
0003c7 dcf5                      	do_lcd_command 0b00001100	; cursor off
0003c8 935f
0003c9 e053
0003ca dc92
0003cb 915f                      	wait_3s
                                 
0003cc e001
0003cd dcd5
0003ce dcee
0003cf e006
0003d0 dcd2
0003d1 dceb
0003d2 e00f
0003d3 dccf
0003d4 dce8                      	clear_display
0003d5 eae0
0003d6 e0f8
0003d7 dd3d                      	print_string PromptStopTime
                                 
                                 stop_time_loop:
0003d8 dda0                      	rcall get_keypad_input
0003d9 9170 0202                 	lds index, KeyPressed
                                 
0003db 3273                      	cpi index, '#'
0003dc f071                      	breq store_time
0003dd 3370                      	cpi index, '0'
0003de f3c9                      	breq stop_time_loop
0003df 3372                      	cpi index, '2'				; this will cover '*' and '0'
0003e0 f3bc                      	brlt stop_time_loop
0003e1 3376                      	cpi index, '6'				; cannot be larger than 5
0003e2 f7ac                      	brge stop_time_loop
                                 
0003e3 2f17                      	mov temp, index				; this stores the value so that if '#' is pressed 
0003e4 2f07                      	mov data, index				; the last value is stored and not '#' 
0003e5 dcc8
0003e6 dcd6                      	print_direct
0003e7 e100
0003e8 dcba
0003e9 dcd3                      	do_lcd_command 0b00010000	; lets user input until '#' is pressed
0003ea cfed                      	rjmp stop_time_loop
                                 		
                                 store_time:
0003eb e8e6                      	ldi zl, low(StopTime)
0003ec e0f2                      	ldi zh, high(StopTime)
0003ed 5310                      	subi temp, '0'
0003ee 8310                      	st z, temp
                                 
                                 stop_time:
0003ef 91ff                      	pop zh
0003f0 91ef                      	pop zl
0003f1 917f                      	pop index
0003f2 910f                      	pop data
0003f3 911f                      	pop temp
0003f4 9508                      	ret 
                                 
                                 
                                 configuration:	
0003f5 935f                      	push count
                                 
0003f6 e001
0003f7 dcab
0003f8 dcc4
0003f9 e006
0003fa dca8
0003fb dcc1
0003fc e00f
0003fd dca5
0003fe dcbe                      	clear_display
0003ff ebe4
000400 e0f8
000401 dd13                      	print_string CompleteMSG
000402 e00c
000403 dc9f
000404 dcb8                      	do_lcd_command 0b00001100	; cursor off
000405 e052                      	ldi count, 2
000406 935f
000407 2f55
000408 dc54
000409 915f                      	wait count							; waits 1 sec
                                 	
00040a e001
00040b dc97
00040c dcb0
00040d e006
00040e dc94
00040f dcad
000410 e00f
000411 dc91
000412 dcaa                      	clear_display
000413 ede0
000414 e0f8
000415 dcff                      	print_string CompleteMSG2
000416 e00c
000417 dc8b
000418 dca4                      	do_lcd_command 0b00001100	; cursor off
000419 935f
00041a e055
00041b dc41
00041c 915f                      	wait_5s
                                 
00041d e001
00041e dc84
00041f dc9d
000420 e006
000421 dc81
000422 dc9a
000423 e00f
000424 dc7e
000425 dc97                      	clear_display
                                 
000426 915f                      	pop count
000427 9508                      
                                 ; All of the user prompts and other strings
000428 6c50
000429 6165
00042a 6573
00042b 7420
00042c 7079
00042d 2065
00042e 6874
00042f 2065
000430 616d
000431 6978
000432 756d
000433 206d
000434 756e
000435 626d
000436 7265
000437 6f20
000438 2066
000439 7473
00043a 7461
00043b 6f69
00043c 736e
00043d 203a                      PromptNumStn:   .db "Please type the maximum number of stations: "
00043e 6c50
00043f 6165
000440 6573
000441 7420
000442 7079
000443 2065
000444 6874
000445 2065
000446 616e
000447 656d
000448 6f20
000449 2066
00044a 7453
00044b 7461
00044c 6f69
00044d 206e
00044e 6e28
00044f 0029                      PromptStnName:  .db "Please type the name of Station (n)", 0
000450 6f4d
000451 6f6e
000452 6172
000453 6c69
000454 7320
000455 6f74
000456 2f70
000457 6974
000458 656d
000459 003a                      PromptStopTime: .db "Monorail stop/time:", 0
00045a 6f43
00045b 666e
00045c 6769
00045d 7275
00045e 7461
00045f 6f69
000460 206e
000461 692f
000462 2073
000463 6f63
000464 706d
000465 656c
000466 6574
000467 002e                      CompleteMSG:	.db "Configuration /is complete.", 0
000468 6157
000469 7469
00046a 3520
00046b 7320
00046c 6365
00046d 6e6f
00046e 7364
00046f 002e                      CompleteMSG2:   .db "Wait 5 seconds.", 0
                                 
000470 6e45
000471 6574
000472 2072
000473 756e
000474 626d
000475 7265
000476 6f20
000477 2f66
000478 7473
000479 7461
00047a 6f69
00047b 736e
00047c 003a                      PromptStnNum:	.db "Enter number of/stations:", 0
00047d 6e45
00047e 6574
00047f 2072
000480 616e
000481 656d
000482 6f20
000483 2f66
000484 6165
000485 6863
000486 7320
000487 6174
000488 6974
000489 6e6f
00048a 002e                      InstrStnNames:	.db "Enter name of/each station.", 0
00048b 6e45
00048c 6574
00048d 2072
00048e 7473
00048f 706f
000490 642f
000491 7275
000492 7461
000493 6f69
000494 2e6e
000495 0000                      InstrStpTime:	.db "Enter stop/duration.", 0, 0
000496 6e45
000497 6574
000498 2072
000499 7274
00049a 7661
00049b 6c65
00049c 742f
00049d 6d69
00049e 7365
00049f 002e                      InstrStnTimes:	.db "Enter travel/times.", 0
0004a0 7453
0004a1 7461
0004a2 6f69
0004a3 206e
0004a4 0000                      LabelStation:	.db "Station ", 0, 0
0004a5 2f3a
0004a6 0000                      LabelStnEnd:	.db ":/", 0, 0
0004a7 7420
0004a8 2f6f
0004a9 0000                      LabelStnTime:	.db " to/", 0, 0
0004aa 6854
0004ab 2065
0004ac 656e
0004ad 7478
0004ae 5320
0004af 6e74
0004b0 6920
0004b1 3a73
0004b2 002f                      NextStn:		.db "The next Stn is:/", 0
                                 
                                 
                                 DEFAULT:
0004b3 9518                      	reti
                                 
                                 RESET:
0004b4 94f8                      	cli
0004b5 2433                      	clr zero
                                 
                                 	; Stack pointer reset
0004b6 ef1f                      	ldi temp, low(RAMEND)
0004b7 bf1d                      	out SPL, temp
0004b8 e211                      	ldi temp, high(RAMEND)
0004b9 bf1e                      	out SPH, temp
                                   
                                 	; LED setup
0004ba ef1f                      	ser temp		
0004bb b917                      	out DDRC, temp		; PORTC is all outputs
0004bc 2711                      	clr temp			; No lights are on at the begininng
0004bd b918                      	out PORTC, temp
                                 
                                 	; Keypad setup
0004be ef10                      	ldi temp, PORTLDIR	; columns are outputs, rows are inputs
0004bf 9310 010a                 	sts DDRL, temp		; cannot use out
                                 
                                 	; LCD port setup
0004c1 ef1f                      	ser temp	
0004c2 bb10                      	out DDRF, temp
0004c3 b911                      	out DDRA, temp
0004c4 2711                      	clr temp
0004c5 bb11                      	out PORTF, temp
0004c6 b912                      	out PORTA, temp
                                 
                                 	; Initialize the LCD
0004c7 e308
0004c8 dbda
0004c9 dbf3                      	do_lcd_command 0b00111000 ; 2x5x7
0004ca db6e                      	rcall sleep_5ms
0004cb e308
0004cc dbd6
0004cd dbef                      	do_lcd_command 0b00111000 ; 2x5x7
0004ce db61                      	rcall sleep_1ms
0004cf e308
0004d0 dbd2
0004d1 dbeb                      	do_lcd_command 0b00111000 ; 2x5x7
0004d2 e308
0004d3 dbcf
0004d4 dbe8                      	do_lcd_command 0b00111000 ; 2x5x7
0004d5 e008
0004d6 dbcc
0004d7 dbe5                      	do_lcd_command 0b00001000 ; display off?
0004d8 e001
0004d9 dbc9
0004da dbe2                      	do_lcd_command 0b00000001 ; clear display
0004db e006
0004dc dbc6
0004dd dbdf                      	do_lcd_command 0b00000110 ; increment, no display shift
0004de e00f
0004df dbc3
0004e0 dbdc                      	do_lcd_command 0b00001111 ; Cursor on, bar, no blink
                                 	
                                 	; External interrupt setup
0004e1 2711                      	clr temp 
0004e2 b91a                      	out DDRD, temp			; Port D is set to all inputs
0004e3 ef1f                      	ser temp
0004e4 b91b                      	out PORTD, temp			; Enable pull up resistors 
                                 
0004e5 e21a                      	ldi temp, (2<<ISC20) | (2<<ISC10) | (2<<ISC00) 
0004e6 9310 0069                 	sts EICRA, temp			; all configured as falling edge triggered interrupts
                                 
0004e8 b31d                      	in temp, EIMSK
0004e9 6017                      	ori temp, (1<<INT0) | (1<<INT1) | (1<<INT2)
0004ea bb1d                      	out EIMSK, temp			; Enable External Interrupts 0, 1, 2
                                 
                                 	; Timer0 interrupt setup
0004eb bc34                      	out TCCR0A, zero		; Setting up the Timer Interrupt
0004ec e012                      	ldi temp, 0b00000010
0004ed bd15                      	out TCCR0B, temp		; set prescalar value to 8
0004ee e011                      	ldi temp, (1<<TOIE0)	; TOIE0 is the bit number of TOIE0 which is 0
0004ef 9310 006e                 	sts TIMSK0, temp		; enable Timer0 Overflow Interrupt
                                 
                                 	; Timer1 interrupt setup for debouncing
0004f1 9230 0080                 	sts TCCR1A, zero
0004f3 e014                      	ldi temp, (1<<CS12)		;(1<<CS11)|(1<<CS10) 64 ; set prescaler to 256
0004f4 9310 0081                 	sts TCCR1B, temp
                                 
                                 	; PWM setup
                                 	;ldi temp, 0b00001000	
0004f6 ef1f                      	ser temp
0004f7 b91d                      	out DDRE, temp			; set PE2 (OC3B) as output, which is bit 3
                                 
0004f8 2711                      	clr temp				; this value and the operation mode determine the PWM duty cycle
0004f9 9310 009b                 	sts OCR3BH, temp
0004fb e41a                      	ldi temp, 0x4a
0004fc 9310 009a                 	sts OCR3BL, temp
                                 
0004fe e011                      	ldi temp, (1<<CS30)		; CS30=1: no prescaling
0004ff 9310 0091                 	sts TCCR3B, temp
                                 	; WGM30=1: phase correct PWM, 8 bits
                                 	; COM3A1=1: make OC3B override the normal port functionality of the I/O pin PE2
000501 ea19                      	ldi temp, (1<< WGM30)|(1<<COM3A1)|(1<< WGM32)|(1<<COM3B1)
000502 9310 0090                 	sts TCCR3A, temp 
                                 
000504 c05d                      	rjmp main
                                 
                                 
                                 EXT_INT0:
000505 931f                      	push temp
000506 b71f                      	in temp, SREG
000507 931f                      	push temp
                                 
000508 db44
000509 f010                      	debounce int0_end
00050a e011                      	ldi temp, 1
00050b 2e91                      	mov sigstop, temp
                                 
                                 	int0_end:
00050c 911f                      	pop temp
00050d bf1f                      	out SREG, temp
00050e 911f                      	pop temp
00050f 9518                      	reti
                                 
                                 
                                 EXT_INT1:
000510 931f                      	push temp
000511 b71f                      	in temp, SREG
000512 931f                      	push temp
                                 
000513 db39
000514 f010                      	debounce int1_end
000515 e011                      	ldi temp, 1
000516 2e91                      	mov sigstop, temp
                                 
                                 	int1_end:
000517 911f                      	pop temp
000518 bf1f                      	out SREG, temp
000519 911f                      	pop temp
00051a 9518                      	reti
                                 
                                 
                                 EXT_INT2: 
00051b 931f                      	push temp
00051c b71f                      	in temp, SREG
00051d 931f                      	push temp
00051e 938f                      	push numl
00051f 939f                      	push numh
                                 
000520 9180 020b                 	lds numl, Revolutions	
000522 9190 020c                 	lds numh, Revolutions+1
000524 9601                      	adiw numh:numl, 1		; just increment the revolutions counter
000525 9380 020b                 	sts Revolutions, numl
000527 9390 020c                 	sts Revolutions+1, numh
                                 
000529 919f                      	pop numh
00052a 918f                      	pop numl
00052b 911f                      	pop temp
00052c bf1f                      	out SREG, temp
00052d 911f                      	pop temp
00052e 9518                      	reti
                                 
                                 
                                 TIMER0_OVF:					; interrupt subroutine to Timer0
00052f 931f                      	push temp				; save all conflicting registers in the prologue 
000530 b71f                      	in temp, SREG			
000531 931f                      	push temp				
000532 938f                      	push r24
000533 939f                      	push r25
                                 
000534 9180 0207                 	lds r24, TempCounter	; Load the value of the temporary counter
000536 9190 0208                 	lds r25, TempCounter+1
000538 9601                      	adiw r25:r24, 1			; increase the temporary counter by one
000539 3884                      	cpi r24, low(7812)		; check if (r25:r24) = 7812
00053a e11e                      	ldi temp, high(7812)	; 7812 from 128 * 16MHz
00053b 0791                      	cpc r25, temp
00053c f479                      	brne not_second
                                 
00053d e0c7
00053e e0d2
00053f 2711
000540 9319
000541 8318                      	clear TempCounter		; reset the temporary counter
                                 
000542 9180 0209                 	lds r24, SecondCounter	; Load and increment the seconds counter
000544 9190 020a                 	lds r25, SecondCounter+1		
000546 9601                      	adiw r25:r24, 1		
000547 9380 0209                 	sts SecondCounter, r24
000549 9390 020a                 	sts SecondCounter+1, r25
                                 	
                                 	; One second has passed, do stuff here
                                 	;
00054b c005                      	rjmp timer_end
                                 
                                 not_second: 
00054c 9380 0207                 	sts TempCounter, r24	; store the new value of the temporary counter
00054e 9390 0208                 	sts TempCounter+1, r25
000550 c000                      	rjmp timer_end
                                 
                                 timer_end: 
000551 919f                      	pop r25					; epilogue starts
000552 918f                      	pop r24					; restore all conflicting registers from the stack
000553 911f                      	pop temp
000554 bf1f                      	out SREG, temp
000555 911f                      	pop temp
000556 9518                      	reti					; return from the interrupt
                                 
                                 
                                 TIMER1_OVF:
000557 931f                      	push temp
000558 b71f                      	in temp, SREG
000559 931f                      	push temp
                                 
00055a 9230 0206                 	sts DebounceFlag, zero	; clear the flag
00055c 9230 006f                 	sts TIMSK1, zero		; this disables timer1
                                 
                                 	timer1_end:
00055e 911f                      	pop temp
00055f bf1f                      	out SREG, temp
000560 911f                      	pop temp
000561 9518                      	reti		
                                 
                                 ;.include "tests.asm"
                                 
                                 ;
                                 ;	Monorail start point
                                 ;
                                 main:
000562 9478                      	sei	; enable global interrupt
                                 
000563 e0c7
000564 e0d2
000565 2711
000566 9319
000567 8318
000568 e0c9
000569 e0d2
00056a 2711
00056b 9319
00056c 8318
00056d e0cb
00056e e0d2
00056f 2711
000570 9319
000571 8318
000572 e0cd
000573 e0d2
000574 2711
000575 8318
000576 e8c6
000577 e0d2
000578 2711
000579 8318
00057a e0c2
00057b e0d2
00057c 2711
00057d 9319
00057e 8318
00057f e0c4
000580 e0d2
000581 2711
000582 9319
000583 8318                      	clear_globals
000584 2499                      	clr sigstop
000585 24aa                      	clr stopped				
000586 e011
000587 26a1                      	toggle stopped			; monorail starts not travelling
                                 	
                                 	; initialize the global values
000588 dcc2                      	rcall get_station_count
000589 dd04                      	rcall get_station_names
00058a dd94                      	rcall get_station_times
00058b de28                      	rcall get_stop_time
00058c de68                      	rcall configuration
                                 
                                 	;test
00058d 2777                      	clr index
                                 	displayN:
00058e 9120 020d                 	lds temp2, StationCount
000590 1772                      	cp index, temp2
000591 f101                      	breq halt
                                 
000592 e001
000593 db0f
000594 db28
000595 e006
000596 db0c
000597 db25
000598 e00f
000599 db09
00059a db22                      	clear_display
00059b e5e4
00059c e0f9
00059d db77                      	print_string NextStn
00059e e0ae
00059f e0b2
0005a0 e01b
0005a1 9f17
0005a2 0da0
0005a3 1db1
0005a4 db83                      	print_stn_name
                                 	
0005a5 e7ac
0005a6 e0b2
0005a7 0fa7
0005a8 0db3                      	set_travel_time_addr
0005a9 911c                      	ld temp, x
0005aa 935f
0005ab 2f51
0005ac dab0
0005ad 915f                      	wait temp
                                 	
0005ae 9573                      	inc index
0005af cfde                      	rjmp displayN
                                 	;test
                                 
0005b0 2777                      	clr index				; start at first station
0005b1 d001                      	rcall monorail_loop
                                 
                                 halt: 
0005b2 cfff                      	rjmp halt
                                 	
                                 
                                 
                                 
                                 
                                 ;
                                 ; do the monorail stuff here
                                 ;
                                 monorail_loop:
                                 
0005b3 1493                      	cp sigstop, zero
0005b4 f039                      	breq no_stopping
                                 
0005b5 9110 0286                 	lds temp, StopTime	
0005b7 935f
0005b8 2f51
0005b9 daa3
0005ba 915f                      	wait temp
0005bb c000                      	rjmp next_station
                                 
                                 no_stopping:
                                 	
                                 
                                 next_station:
0005bc e7ac
0005bd e0b2
0005be 0fa7
0005bf 0db3                      	set_travel_time_addr
0005c0 911c                      	ld temp, x
0005c1 e001
0005c2 dae0
0005c3 daf9
0005c4 e006
0005c5 dadd
0005c6 daf6
0005c7 e00f
0005c8 dada
0005c9 daf3                      	clear_display	
0005ca e0ae
0005cb e0b2
0005cc e01b
0005cd 9f17
0005ce 0da0
0005cf 1db1
0005d0 db57                      	print_stn_name				; This will display the next station name
0005d1 935f
0005d2 2f51
0005d3 da89
0005d4 915f                      	wait temp					; Waits for time in between each station
                                 
                                 
                                 
0005d5 9110 020d                 	lds temp, StationCount		; checking if station count is equal to count. If so we have visited each station
0005d7 1751                      	cp count, temp
0005d8 f051                      	breq mono_final
                                 
                                 	; poll keypad for the '#' key, if pressed stop everything otherwise continue
0005d9 db9f                      	rcall get_keypad_input
0005da 9170 0202                 	lds index, KeyPressed
0005dc 3273                      	cpi index, '#'
0005dd f019                      	breq train_stop
                                 
                                 	station:
                                 		; stop at station for time in StopTime
0005de d005                      		rcall station_stop
0005df 9553                      		inc count					; increase count as next station has been visited
0005e0 c001                      		rjmp mono_end
                                 
                                 	train_stop:	
                                 		; rcall emergency_stop
0005e1 c000                      		rjmp mono_end
                                 
                                 		; get the index of the StationNames and rcall print_string
                                 		; continue this until time is up
                                 
                                 
                                 mono_end:
0005e2 cfd0                      	rjmp monorail_loop			; repeat
                                 
                                 mono_final:						; all stations have been visited, need to reset?
0005e3 cfff                      	rjmp mono_final
                                 
                                 
                                 
                                 
                                 ;
                                 ;function to stop train for given time at each stop
                                 ;
                                 station_stop:
0005e4 931f                      	push temp
0005e5 935f                      	push count
0005e6 93ef                      	push zl
0005e7 93ff                      	push zh
                                 
                                 	; check if push button has been pressed, if so make a stop, otherwise continue on
0005e8 e011                      	ldi temp, 1
0005e9 1691                      	cp sigstop, temp
0005ea f001                      	breq next_stop
                                 
                                 	; otherwise jmp back to where timer is from station to station
                                 
                                 	next_stop:
                                 		; stop the motor
                                 
0005eb 91e0 0086                 		lds zl, low(StopTime)
0005ed 91f0 0002                 		lds zh, high(StopTime)
                                 
0005ef 8110                      		ld temp, z
0005f0 e350                      		ldi count, '0'
                                 
                                 		station_stop_loop:
0005f1 1751                      			cp count, temp
0005f2 f011                      			breq ret_station_stop
                                 
                                 			; call 1 sec delay
                                 
0005f3 9553                      			inc count
0005f4 cffc                      			rjmp station_stop_loop
                                 				
                                 ret_station_stop:
                                 
0005f5 91ff                      	pop zh
0005f6 91ef                      	pop zl
0005f7 915f                      	pop count
0005f8 911f                      	pop temp
                                 
0005f9 9508                      	ret
                                 
                                 ;
                                 ; stops the train if '#' is pressed, waits until '#' pressed again to go
                                 ;
                                 emergency_stop:
0005fa 937f                      	push index
                                 
                                 	emergency_loop:
                                 		; stop train
0005fb db7d                      		rcall get_keypad_input
0005fc 9170 0202                 		lds index, KeyPressed
0005fe 3273                      		cpi index, '#'
0005ff f7d9                      		brne emergency_loop
                                 
000600 917f                      	pop index
                                 
000601 9508                      ret
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2560" register use summary:
x  :   8 y  :  28 z  :   3 r0 :   5 r1 :  11 r2 :   0 r3 :  15 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   5 r10:   5 r11:   9 r12:   8 
r13:   5 r14:  10 r15:   0 r16: 131 r17: 281 r18:  38 r19:  15 r20:  10 
r21:  85 r22:  44 r23:  64 r24:  49 r25:  48 r26:  20 r27:  20 r28:  17 
r29:  17 r30:  23 r31:  23 
Registers used: 28 out of 35 (80.0%)

"ATmega2560" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   8 add   :  32 adiw  :   3 and   :   1 
andi  :   1 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   3 break :   0 breq  :  42 brge  :  11 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   4 brlt  :   8 brmi  :   0 
brne  :  10 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   5 cbr   :   0 
clc   :  14 clh   :   0 cli   :   1 cln   :   0 clr   :  46 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :  24 cpc   :   4 
cpi   :  46 cpse  :   0 dec   :   3 eicall:   0 eijmp :   0 elpm  :   0 
eor   :   2 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :   7 inc   :  17 jmp   :  12 ld    :   5 ldd   :   0 ldi   : 198 
lds   :  49 lpm   :   1 lsl   :   9 lsr   :   0 mov   :  29 movw  :   0 
mul   :   5 muls  :   0 mulsu :   0 neg   :   0 nop   :  20 or    :   0 
ori   :   1 out   :  24 pop   : 111 push  : 111 rcall : 219 ret   :  28 
reti  :   6 rjmp  :  36 rol   :  19 ror   :   8 sbc   :   1 sbci  :   0 
sbi   :   5 sbic  :   0 sbis  :   0 sbiw  :   1 sbr   :   0 sbrc  :   1 
sbrs  :   0 sec   :   2 seh   :   0 sei   :   1 sen   :   0 ser   :   5 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :  33 std   :   0 sts   :  30 sub   :   3 subi  :   7 swap  :   0 
tst   :   0 wdr   :   0 
Instructions used: 52 out of 116 (44.8%)

"ATmega2560" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000c04   2726    278   3004  262144   1.1%
[.dseg] 0x000200 0x000287      0    135    135    8192   1.6%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
